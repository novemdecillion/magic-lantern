/*
 * This file is generated by jOOQ.
 */
package io.github.novemdecillion.adapter.jooq.tables.daos


import io.github.novemdecillion.adapter.jooq.tables.NoticeTable
import io.github.novemdecillion.adapter.jooq.tables.pojos.NoticeEntity
import io.github.novemdecillion.adapter.jooq.tables.records.NoticeRecord

import java.time.LocalDate
import java.time.OffsetDateTime
import java.util.UUID

import kotlin.collections.List

import org.jooq.Configuration
import org.jooq.impl.DAOImpl


/**
 * This class is generated by jOOQ.
 */
@Suppress("UNCHECKED_CAST")
open class NoticeDao(configuration: Configuration?) : DAOImpl<NoticeRecord, NoticeEntity, UUID>(NoticeTable.NOTICE, NoticeEntity::class.java, configuration) {

    /**
     * Create a new NoticeDao without any configuration
     */
    constructor(): this(null)

    override fun getId(o: NoticeEntity): UUID? = o.noticeId

    /**
     * Fetch records that have <code>notice_id BETWEEN lowerInclusive AND upperInclusive</code>
     */
    fun fetchRangeOfNoticeIdTable(lowerInclusive: UUID?, upperInclusive: UUID?): List<NoticeEntity> = fetchRange(NoticeTable.NOTICE.NOTICE_ID, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>notice_id IN (values)</code>
     */
    fun fetchByNoticeIdTable(vararg values: UUID): List<NoticeEntity> = fetch(NoticeTable.NOTICE.NOTICE_ID, *values)

    /**
     * Fetch a unique record that has <code>notice_id = value</code>
     */
    fun fetchOneByNoticeIdTable(value: UUID): NoticeEntity? = fetchOne(NoticeTable.NOTICE.NOTICE_ID, value)

    /**
     * Fetch records that have <code>message BETWEEN lowerInclusive AND upperInclusive</code>
     */
    fun fetchRangeOfMessageTable(lowerInclusive: String?, upperInclusive: String?): List<NoticeEntity> = fetchRange(NoticeTable.NOTICE.MESSAGE, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>message IN (values)</code>
     */
    fun fetchByMessageTable(vararg values: String): List<NoticeEntity> = fetch(NoticeTable.NOTICE.MESSAGE, *values)

    /**
     * Fetch records that have <code>start_at BETWEEN lowerInclusive AND upperInclusive</code>
     */
    fun fetchRangeOfStartAtTable(lowerInclusive: LocalDate?, upperInclusive: LocalDate?): List<NoticeEntity> = fetchRange(NoticeTable.NOTICE.START_AT, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>start_at IN (values)</code>
     */
    fun fetchByStartAtTable(vararg values: LocalDate): List<NoticeEntity> = fetch(NoticeTable.NOTICE.START_AT, *values)

    /**
     * Fetch records that have <code>end_at BETWEEN lowerInclusive AND upperInclusive</code>
     */
    fun fetchRangeOfEndAtTable(lowerInclusive: LocalDate?, upperInclusive: LocalDate?): List<NoticeEntity> = fetchRange(NoticeTable.NOTICE.END_AT, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>end_at IN (values)</code>
     */
    fun fetchByEndAtTable(vararg values: LocalDate): List<NoticeEntity> = fetch(NoticeTable.NOTICE.END_AT, *values)

    /**
     * Fetch records that have <code>update_at BETWEEN lowerInclusive AND upperInclusive</code>
     */
    fun fetchRangeOfUpdateAtTable(lowerInclusive: OffsetDateTime?, upperInclusive: OffsetDateTime?): List<NoticeEntity> = fetchRange(NoticeTable.NOTICE.UPDATE_AT, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>update_at IN (values)</code>
     */
    fun fetchByUpdateAtTable(vararg values: OffsetDateTime): List<NoticeEntity> = fetch(NoticeTable.NOTICE.UPDATE_AT, *values)
}
